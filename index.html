<html>
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Crypto Jump — Test</title>
    <style>
      html,body,#root,canvas{height:100%;margin:0;background:#000;color:#fff;font-family:system-ui,Segoe UI,Roboto,Helvetica,Arial}
      .hud{position:fixed;left:12px;right:12px;top:12px;display:flex;gap:8px;flex-wrap:wrap;align-items:center;z-index:10}
      .pill{background:#111;border:1px solid #333;border-radius:10px;padding:6px 10px}
      .btn{cursor:pointer}
      .footer{position:fixed;left:12px;right:12px;bottom:12px;display:flex;justify-content:space-between;gap:8px;z-index:10}
    </style>
  </head>
  <body>
    <div class="hud">
      <div class="pill">Equity (USDT): <span id="equity">100.00</span></div>
      <div class="pill">Balance USDT: <span id="bal">100.00</span></div>
      <div class="pill">Asset: <span id="asset">USDT</span></div>
      <div class="pill">If exit now: <span id="exitpnl">0.00</span> USDT</div>
      <div class="pill">Lag: <span id="lag">—</span> ms</div>
      <div class="pill btn" id="panic">Panic to USDT</div>
      <div class="pill">Stake: <span id="stakeLabel">25%</span></div>
      <div class="pill">[1]=10% [2]=25% [3]=50% [4]=100% [Space]=Jump to Leader</div>
      <div class="pill">Fee: 0.1% + 0.01 USDT</div>
    </div>
    <canvas id="cv"></canvas>
    <div class="footer">
      <div class="pill">Click a column to jump. Shift-click = 50% once.</div>
      <div class="pill">Demo only. Prices: Binance bookTicker.</div>
    </div>
    <script>
      const TICKERS=['BTCUSDT','ETHUSDT','BNBUSDT','SOLUSDT','TONUSDT','XRPUSDT','ADAUSDT','DOGEUSDT'];
      // по символу храним: bid, ask, ts, mid, hist (последние 20с)
      const qmap={};
      let asset='USDT';
      let balances={USDT:100};
      let stakePct=0.25; // 25% по умолчанию
      const START_EQUITY=100;

      const FEE_RATE=0.001; // 0.1%
      const FEE_GAME=0.01;  // 0.01 USDT фикс
      const TREND_WINDOW_MS = 5000;   // 5s тренд
      const HIST_MAX_MS = 20000;      // 20s спарклайн

      // учёт позиции для «If exit now»
      // трекаем среднюю цену входа в USDT и количество по текущему asset
      let pos = { asset: 'USDT', qty: 0, entryUSDT: 0 };

      const cv=document.getElementById('cv');
      const ctx=cv.getContext('2d');
      const elBal=document.getElementById('bal');
      const elAsset=document.getElementById('asset');
      const elLag=document.getElementById('lag');
      const elStake=document.getElementById('stakeLabel');
      const elEquity=document.getElementById('equity');
      const elExit=document.getElementById('exitpnl');

      document.getElementById('panic').onclick=()=>jump('USDT',1);

      function fmt(n, d=2){return (Number(n)||0).toFixed(d)}
      function mid(q){return (q.bid+q.ask)/2}
      function qget(sym){return qmap[sym]}
      function now(){return Date.now()}

      function redrawHUD(){
        elBal.textContent=fmt(balances.USDT||0);
        elAsset.textContent=asset;
        elStake.textContent=Math.round(stakePct*100)+'%';
        elEquity.textContent=fmt(equityUSDT());
        elExit.textContent = fmt(projectedExitPNL());
      }

      // Equity в USDT
      function equityUSDT(){
        let total = 0;
        for(const [k,v] of Object.entries(balances)){
          if(k==='USDT'){ total += v; continue; }
          const q = qget(k+'USDT');
          if(q) total += v * q.mid;
        }
        return total;
      }

      // Прогноз PnL если выйти сейчас из текущего asset в USDT с учётом комиссий
      function projectedExitPNL(){
        if(asset==='USDT') return 0;
        const qty = balances[asset] || 0;
        const q = qget(asset+'USDT');
        if(!q) return 0;
        const gross = qty * q.mid;
        const net = Math.max(0, gross * (1 - FEE_RATE) - FEE_GAME);
        // pos.entryUSDT — сколько USDT (нетто) было потрачено на текущий asset
        const entry = (pos.asset===asset) ? pos.entryUSDT : 0;
        return net - entry;
      }

      function updatePositionOnBuy(toAsset, qtyBought, netUSDTSpent){
        if(pos.asset!==toAsset){
          pos = { asset: toAsset, qty: 0, entryUSDT: 0 };
        }
        // усредняем
        pos.qty += qtyBought;
        pos.entryUSDT += netUSDTSpent;
      }
      function clearPosition(){
        pos = { asset: 'USDT', qty: 0, entryUSDT: 0 };
      }
      function reducePositionOnSell(fromAsset, qtySold, netUSDTReceived){
        if(pos.asset!==fromAsset || pos.qty<=0) return;
        const portion = Math.min(1, qtySold / pos.qty);
        pos.qty -= qtySold;
        pos.entryUSDT *= (1 - portion); // пропорционально уменьшаем базу
        if(pos.qty<=1e-12) clearPosition();
      }

      // Комиссии вычитаем из самого трейда
      function jump(toAsset, pctOverride){
        const pct = typeof pctOverride==='number' ? pctOverride : stakePct;
        if(toAsset===asset) return;
        const from=asset;
        const fromAmt=(balances[from]||0)*pct;
        if(fromAmt<=0) return;

        const t=now();
        const fresh = (q)=> q && t - q.ts <= 1500;

        if(from==='USDT'){ 
          const q=qget(toAsset+'USDT'); if(!fresh(q)) return alert('No fresh quote');
          const notionalUSDT = fromAmt;
          const feeEx = notionalUSDT*FEE_RATE;
          const feeGame = FEE_GAME;
          const netUSDT = notionalUSDT - feeEx - feeGame;
          if(netUSDT<=0) return alert('Too small amount for fees');
          const qty = netUSDT / q.mid;

          balances.USDT -= fromAmt;
          balances[toAsset]=(balances[toAsset]||0)+qty;

          // апдейт позиции
          updatePositionOnBuy(toAsset, qty, netUSDT);

        } else if(toAsset==='USDT'){
          const q=qget(from+'USDT'); if(!fresh(q)) return alert('No fresh quote');
          const grossUSDT = fromAmt * q.mid;
          const feeEx = grossUSDT*FEE_RATE;
          const feeGame = FEE_GAME;
          const netUSDT = Math.max(0, grossUSDT - feeEx - feeGame);

          balances[from] -= fromAmt;
          balances.USDT = (balances.USDT||0) + netUSDT;

          // уменьшаем позицию пропорционально
          reducePositionOnSell(from, fromAmt, netUSDT);
          if((balances[from]||0)<=1e-12 && asset!==toAsset) clearPosition();

        } else {
          // from -> USDT -> toAsset
          const q1=qget(from+'USDT'); const q2=qget(toAsset+'USDT');
          if(!fresh(q1)||!fresh(q2)) return alert('No fresh quote');

          const grossUSDT = fromAmt * q1.mid;
          const feeEx1 = grossUSDT*FEE_RATE;
          const feeGame1 = FEE_GAME;
          const midUSDT = Math.max(0, grossUSDT - feeEx1 - feeGame1); // после продажи from

          const feeEx2 = midUSDT*FEE_RATE;
          const feeGame2 = FEE_GAME;
          const netUSDT = Math.max(0, midUSDT - feeEx2 - feeGame2); // что реально пошло в покупку
          const qty = netUSDT / q2.mid;

          balances[from] -= fromAmt;
          balances[toAsset]=(balances[toAsset]||0)+qty;

          // позицию по from уменьшаем
          reducePositionOnSell(from, fromAmt, midUSDT);
          // позицию по to увеличиваем
          updatePositionOnBuy(toAsset, qty, netUSDT);
        }

        asset=toAsset;
        redrawHUD();
      }

      // Рендер
      let lastEquity = START_EQUITY;
      let animEquity = START_EQUITY;

      function trendPct(sym){
        const q = qget(sym);
        if(!q || !q.hist || q.hist.length<2) return 0;
        const t = now();
        // точка ~5с назад
        let base = q.hist[0];
        for(let i=q.hist.length-1;i>=0;i--){
          if(t - q.hist[i].ts >= TREND_WINDOW_MS){ base = q.hist[i]; break; }
          base = q.hist[0];
        }
        const baseMid = base.mid;
        if(!baseMid) return 0;
        return (q.mid - baseMid) / baseMid * 100;
      }

      function bestAndWorst(){
        let best = {sym:null,pct:-Infinity}, worst={sym:null,pct:Infinity};
        for(const s of TICKERS){
          const p=trendPct(s);
          if(p>best.pct) best={sym:s,pct:p};
          if(p<worst.pct) worst={sym:s,pct:p};
        }
        return {best, worst};
      }

      function drawSpark(sym, x, y, w, h){
        const q=qget(sym);
        if(!q || !q.hist || q.hist.length<2) return;
        const hist = q.hist;
        // нормализуем по min/max
        let min=Infinity, max=-Infinity;
        for(const p of hist){ if(p.mid<min) min=p.mid; if(p.mid>max) max=p.mid; }
        if(min===max){ min -= 1e-9; max += 1e-9; }
        ctx.beginPath();
        for(let i=0;i<hist.length;i++){
          const p = hist[i];
          const tNorm = (p.ts - hist[0].ts) / (hist[hist.length-1].ts - hist[0].ts || 1);
          const xx = x + tNorm * w;
          const yy = y + h - ((p.mid - min)/(max - min)) * h;
          if(i===0) ctx.moveTo(xx, yy); else ctx.lineTo(xx, yy);
        }
        ctx.strokeStyle = '#aaa';
        ctx.lineWidth = 1;
        ctx.stroke();
      }

      function loop(){
        cv.width=innerWidth; cv.height=innerHeight; 
        const W=cv.width,H=cv.height;
        ctx.fillStyle='#000'; ctx.fillRect(0,0,W,H);

        // лидеры/аутсайдеры
        const {best, worst} = bestAndWorst();

        // кошелёк
        const eq = equityUSDT();
        animEquity += (eq - animEquity) * 0.15;
        const colH = 160 + Math.max(0, animEquity - START_EQUITY) * (80/50);
        const walletX = 20, walletW = Math.min(120, Math.max(90, W*0.08));
        const walletColor = eq > lastEquity + 0.01 ? '#2ecc71' : (eq < lastEquity - 0.01 ? '#e74c3c' : '#1e90ff');

        const wy = H - colH - 40;
        ctx.fillStyle = walletColor;
        ctx.fillRect(walletX, wy, walletW, colH);
        ctx.strokeStyle = '#555';
        ctx.strokeRect(walletX, wy, walletW, colH);
        ctx.fillStyle = '#fff';
        ctx.font = 'bold 14px sans-serif';
        ctx.fillText('WALLET', walletX + 8, wy + 20);
        ctx.fillText('Eq: ' + fmt(eq), walletX + 8, wy + 40);
        const pnlPct = ((eq - START_EQUITY) / START_EQUITY) * 100;
        ctx.fillText('PnL: ' + fmt(pnlPct, 1) + '%', walletX + 8, wy + 60);

        // колонны тикеров с трендом
        const usableWidth = W - (walletX + walletW + 30) - 20;
        const startX = walletX + walletW + 30;
        const cw = Math.max(100, usableWidth / TICKERS.length - 20);
        const baseYCols = H*0.65;

        TICKERS.forEach((sym,i)=>{
          const chg = trendPct(sym); // % за 5с

          // лёгкое «дрожание» у лидера
          const isLeader = best.sym===sym;
          const shake = isLeader ? Math.sin(Date.now()/100) * 3 : 0;

          // высота и цвет колонны зависят от тренда
          const trendBoost = Math.max(-1, Math.min(1, chg/1.5)); // ограничим влияние
          const h = 120 + trendBoost * 30; // «дышит» по тренду
          const x = startX + i * (cw + 20) + shake;
          const y = baseYCols - h/2;

          const isCurrent = (asset+'USDT'===sym) || (asset==='USDT' && sym.endsWith('USDT'));
          let fill = '#222';
          if(chg > 0.02) fill = '#143d1f'; // зелёный фон при росте
          if(chg < -0.02) fill = '#3a1515'; // красный фон при падении
          if(isCurrent) fill = '#1e90ff';

          ctx.fillStyle = fill;
          ctx.fillRect(x,y,cw,h);

          // рамки: лидер — неоновая, аутсайдер — красная
          if(isLeader){
            ctx.strokeStyle = '#00ffae';
            ctx.lineWidth = 3;
          } else if (worst.sym===sym){
            ctx.strokeStyle = '#ff3b3b';
            ctx.lineWidth = 2;
          } else {
            ctx.strokeStyle = '#555';
            ctx.lineWidth = 1;
          }
          ctx.strokeRect(x,y,cw,h);
          ctx.lineWidth = 1;

          // подписи
          ctx.fillStyle='#fff'; ctx.font='bold 14px sans-serif';
          ctx.fillText(sym,x+8,y+20);
          const q=qget(sym); 
          if(q){ 
            ctx.fillText('mid: '+fmt(q.mid),x+8,y+38);
            const arrow = chg>0 ? '↑' : (chg<0 ? '↓' : '→');
            ctx.fillStyle = chg>0 ? '#2ecc71' : (chg<0 ? '#e74c3c' : '#d0d0d0');
            ctx.fillText(`${arrow} ${fmt(chg,2)}%/5s`, x+8, y+56);
            // спарклайн
            drawSpark(sym, x+8, y+h-34, cw-16, 26);
          }
        });

        lastEquity = eq;
        requestAnimationFrame(loop);
      }

      // клик по колонне — прыжок (Shift = 50% разово)
      cv.addEventListener('click', (e)=>{
        const rect=cv.getBoundingClientRect(); 
        const x=e.clientX-rect.left; 
        const y=e.clientY-rect.top;
        const W=cv.width, H=cv.height;

        // кошелёк — не кликабелен
        const walletX = 20, walletW = Math.min(120, Math.max(90, W*0.08));
        const colH = 160 + Math.max(0, equityUSDT() - START_EQUITY) * (80/50);
        const wy = H - colH - 40;
        if(x>=walletX && x<=walletX+walletW && y>=wy && y<=wy+colH){
          return;
        }

        // вычисляем индекс тикера
        const usableWidth = W - (walletX + walletW + 30) - 20;
        const startX = walletX + walletW + 30;
        const cw = Math.max(100, usableWidth / TICKERS.length - 20);
        const stride = cw + 20;

        const idx = Math.floor((x - startX) / stride);
        if(idx < 0 || idx >= TICKERS.length) return;

        const colX = startX + idx*stride;
        const ch = 120; // базовая высота для попадания
        const colY = H*0.65 - ch/2;
        if(!(x>=colX && x<=colX+cw && y>=colY && y<=colY+ch)) return;

        const sym=TICKERS[idx]; 
        const to=sym.replace('USDT',''); 
        const pct = e.shiftKey ? 0.5 : undefined;
        jump(to, pct);
      });

      // горячие клавиши для ставки и «jump to leader»
      window.addEventListener('keydown', (e)=>{
        if(e.key==='1') { stakePct=0.10; redrawHUD(); }
        if(e.key==='2') { stakePct=0.25; redrawHUD(); }
        if(e.key==='3') { stakePct=0.50; redrawHUD(); }
        if(e.key==='4') { stakePct=1.00;  redrawHUD(); }
        if(e.code==='Space'){ 
          e.preventDefault();
          const {best} = bestAndWorst();
          if(best.sym){
            const to = best.sym.replace('USDT','');
            jump(to);
          }
        }
      });

      // Binance WS multi-stream
      const streams=TICKERS.map(s=>s.toLowerCase()+'@bookTicker').join('/');
      const ws=new WebSocket('wss://stream.binance.com:9443/stream?streams='+streams);
      ws.onmessage=(ev)=>{
        const m=JSON.parse(ev.data); 
        const d=m.data;
        const t=now();
        const symbol=d.s;
        const midPx=(Number(d.b)+Number(d.a))/2;
        const prev = qmap[symbol];
        const entry = { bid:Number(d.b), ask:Number(d.a), ts:t, mid:midPx, hist: (prev?.hist||[]) };
        // пушим в историю
        entry.hist.push({ts:t, mid:midPx});
        // чистим старше 20с
        const cutoff = t - HIST_MAX_MS;
        while(entry.hist.length && entry.hist[0].ts < cutoff) entry.hist.shift();
        qmap[symbol] = entry;

        const lastTs=t; elLag.textContent=String(Math.max(0,now()-lastTs));
        elEquity.textContent = fmt(equityUSDT());
        elExit.textContent = fmt(projectedExitPNL());
      };

      redrawHUD(); loop();
    </script>
  </body>
</html>
